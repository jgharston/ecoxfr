*BASIC
NEW
AUTO
REM>Ecofile
:
OSWORD=&FFF1
OSBYTE=&FFF4
OSFILE=&FFDD
OSGBPB=&FFD1
OSFIND=&FFCE
OSASCI=&FFE3
OSNEWL=&FFE7
OSWRCH=&FFEE
:
OP_HDR=&01
OP_BLKREQ=&81
OP_BLKSND=&02
:
codebuf%=1600
DIM code% codebuf%
scratch=&70
scratchsize=5
polltimeout=500
txtimeout%=500
rxtimeout%=500
:
polldelay%=10
polltimeout%=500
buflen=300
maxxfr%=256
srv_port%=100
cli_port%=101
DIM cblock 13,buffer buflen
:
DIM F 100,S 20
:
PROCassemble
:
REM test send routine
$F="T1"
!S=11
S!2=F
X%=S
Y%=S DIV 256
PRINT "Sending..."
PRINT ~USR(send)
END
:
REPEAT
INPUT "T(ransmit), R(eceive) or P(kttest)? " dir$
UNTIL INSTR("TRP",dir$)<>0
:
IF dir$="P" THEN PROCpkttest
:
REPEAT
INPUT "Remote station (0=any)? " station%
UNTIL station%>=0 AND station%<=254
:
IF dir$="T" THEN PROCtransmit
IF dir$="R" THEN PROCreceive
PRINT "End program"
END
:
DEFPROCtransmit
LOCAL filenamelen%,result%
INPUT "Filename? " filename$
IF 18+LEN(filename$)+1>=buflen THEN PRINT "Filename too long":STOP
:
$(buffer+18)=filename$
!buffer=buffer+18
A%=5
X%=buffer MOD 256
Y%=buffer DIV 256
result%=USR(OSFILE) AND &FF
IF result%<>1 THEN PRINT "File error":STOP
len%=buffer!10
PRINT filename$;" ";~buffer!2;" ";~buffer!6;" ";~len%
:
?buffer=OP_HDR
buffer?1=cli_port%
result%=FNtx(station%,srv_port%,buffer,18+LEN(filename$)+1)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
:
A%=64:REM open for input
X%=(buffer+18) MOD 256
Y%=(buffer+18) DIV 256
fh%=USR(OSFIND) AND &FF
IF fh%=0 THEN PRINT "Error opening file":STOP
:
xfrbytes%=0
REPEAT
REPEAT
bytes%=FNrx(station%,cli_port%,buffer,9)
IF bytes%<>9 THEN PRINT "Illegal next block":STOP
IF ?buffer<>OP_BLKREQ THEN PRINT "Unexpected operation ";~?buffer
UNTIL ?buffer=OP_BLKREQ
PRINT ;~buffer!1;" ";
IF buffer!1<>xfrbytes% THEN PRINT "Error - we're expecting &";~xfrbytes%:STOP
:
filebytes%=FNmin(maxxfr%,len%-xfrbytes%)
?buffer=fh%
buffer!1=buffer+13
filebytes%=FNmin(maxxfr%,len%-xfrbytes%)
buffer!5=filebytes%
A%=4:REM read at curr pos
X%=buffer MOD 256
Y%=buffer DIV 256
IF (USR(OSGBPB) AND &1000000)<>0 THEN PRINT "Error reading file":STOP
:
buffer?8=OP_BLKSND
buffer!9=xfrbytes%
result%=FNtx(station%,srv_port%,buffer+8,filebytes%+5)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
xfrbytes%=xfrbytes%+filebytes%
UNTIL xfrbytes%>=len%
PRINT "=";~xfrbytes%
:
A%=0
Y%=fh%
CALL OSFIND
ENDPROC
:
DEFPROCreceive
LOCAL bytes%
REPEAT
PRINT "Waiting for TX start..."
bytes%=FNrx(station%,srv_port%,buffer,buflen)
IF bytes%<0 THEN PRINT "Nothing received"
UNTIL bytes%>=0
IF bytes%<20 THEN PRINT "Illegal info block (too small)":STOP
IF ?buffer<>OP_HDR THEN PRINT "Unexpected operation ";~?buffer:STOP
:
station%=cblock!3 AND &FFFF
port%=buffer?1
name$=$(buffer+18)
load%=buffer!2
exec%=buffer!6
len%=buffer!10
PRINT FNstation(station%);":";port%;" ";name$;" ";~load%;" ";~exec%;" ";~len%
:
A%=128:REM open for output
X%=(buffer+17) MOD 256
Y%=(buffer+17) DIV 256
fh%=USR(OSFIND) AND &FF
IF fh%=0 THEN PRINT "Error opening file":STOP
:
xfrbytes%=0
REPEAT
PRINT ;~xfrbytes%;" ";
?buffer=OP_BLKREQ
buffer!1=xfrbytes%
buffer!5=maxxfr%
result%=FNtx(station%,port%,buffer,9)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
:
bytes%=FNrx(station%,srv_port%,buffer+8,maxxfr%+5)
IF buffer?8<>OP_BLKSND THEN PRINT "Invalid block type received":STOP
IF buffer!9<>xfrbytes% THEN PRINT "Incorrect position":STOP
IF bytes%-5>len%-xfrbytes% THEN PRINT "Oversize block":STOP
:
?buffer=fh%
buffer!1=buffer+13
buffer!5=bytes%-5
A%=2:REM append
X%=buffer MOD 256
Y%=buffer DIV 256
IF (USR(OSGBPB) AND &1000000)<>0 THEN PRINT "Error writing file":STOP
:
xfrbytes%=xfrbytes%+bytes%-5
UNTIL xfrbytes%>=len%
PRINT "=";~xfrbytes%
:
A%=0
Y%=fh%
CALL OSFIND
:
REM write file metadata
$(buffer+18)=name$
!buffer=buffer+18
buffer!2=load%
A%=2:REM write load addr
X%=buffer MOD 256
Y%=buffer DIV 256
CALL OSFILE
A%=3:REM write exec addr
buffer!6=exec%
CALL OSFILE
:
ENDPROC
:
DEFPROCassemble
FOR pass%=0 TO 1
P%=code%
[ OPT pass%*2
\ --- SEND ---
:
.send
\ Entry - YX=sendblk
\   sendblk - +0=dest stn
\             +2=filename addr
\ Exit  - ?
:
\ save scratch
LDA scratch
PHA
LDA scratch+1
PHA
\ XY in scratch
STX scratch
STY scratch+1
\ store peer address
LDY #0
LDA (scratch),Y
STA peeraddr
INY
LDA (scratch),Y
STA peeraddr+1
\ store filename addr
INY
LDA (scratch),Y
STA fnameaddr
INY
LDA (scratch),Y
STA fnameaddr+1
:
\ GET FILE INFORMATION
:
\ copy filename addr to OSFILE
\ param block
LDA fnameaddr
STA buffer
LDA fnameaddr+1
STA buffer+1
:
LDA #5 \ read cat info for file
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSFILE
CMP #1 \ =file found
BEQ filefound
\ not found
JSR scratchrestore
BRK
EQUB 214
EQUS "File not found"
EQUB 0
:
\ BUILD + TX HEADER
:
.filefound
\ populate buffer to send;
\ we can use the OSFILE param
\ block but just change the
\ first two bytes and put the
\ filename on the end
LDA #OP_HDR
STA buffer
LDA #cli_port%
STA buffer+1
LDA peeraddr
STA buffer+2
LDA peeraddr+1
STA buffer+3
\ TODO- should trim to leaf name
LDA fnameaddr
STA scratch
LDA fnameaddr+1
STA scratch+1
LDY #0
.loop
LDA (scratch),Y
STA buffer+18,Y
INY
CMP #13
BNE loop
:
\ store size of buffer in cblock
\ (filename len + 18 bytes for
\ rest of header)
TYA
CLC
ADC #18
STA cblock+8
:
\ set up rest of tx cblock
LDA #srv_port%
STA cblock+1
\ copy dest addr
LDA peeraddr
STA cblock+2
LDA peeraddr+1
STA cblock+3
\ put start addr in cblock
LDA #buffer AND &FF
STA cblock+4
LDA #buffer DIV &100
STA cblock+5
\ put end addr in cblock (start
\ addr + len calculated above)
LDA #buffer AND &FF
ADC cblock+8 \ filename len
STA cblock+8
LDA #buffer DIV &100
ADC #0
STA cblock+9
\ never >64K so no need to do
\ carry - zero top of 32-bit
\ addrs
LDA #0
STA cblock+6
STA cblock+7
STA cblock+10
STA cblock+11
\ do tx
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR tx
CPX #0
BEQ openin
JMP neterror
:
\ PREPARE FOR TX FILE BLOCKS
:
.openin
\ tx header sent - open file
LDA #&40 \ =openin
LDX fnameaddr
LDY fnameaddr+1
JSR OSFIND
STA fhandle
TAX
BNE openinok
JSR scratchrestore
BRK
EQUB 214
EQUS "File open error"
EQUB 0
:
.openinok
\ initialise 'bytes so far'
LDA #0
STA xfrbytes
STA xfrbytes+1
STA xfrbytes+2
STA xfrbytes+3
:
\ TX REQUEST BLOCK LOOP
:
.txblkloop
:
\ print next byte expected to tx
LDA #13 \ back to line start
JSR OSWRCH
LDX #xfrbytes AND &FF
LDY #xfrbytes DIV &100
JSR wrdouble
:
\ TODO- handle if we didn't xfer
\ all of buffer last time, just
\ shuffle along what's left
LDA fhandle
STA buffer
\ buffer to read bytes from file
\ after OSGBPB param block
\ (which leaves space for
\ request block, too)
LDA #(buffer+13) AND &FF
STA buffer+1
LDA #(buffer+13) DIV &100
STA buffer+2
LDA #0
STA buffer+5
LDA #1
STA buffer+6
\ zero top of 32-bit addrs
LDA #0
STA buffer+3
STA buffer+4
STA buffer+7
STA buffer+8
LDA #4
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSGBPB
BCC waitblkreq
:
\ error reading file - tidy up
\ and abort
JMP abortsend
BRK
EQUB 214
EQUS "File read error"
EQUB 0
:
.waitblkreq
\ set up rx cblock
LDA #cli_port%
STA cblock+2
\ copy sender addr
LDA peeraddr
STA cblock+3
LDA peeraddr+1
STA cblock+4
\ set start addr
LDA #buffer AND &FF
STA cblock+5
LDA #buffer DIV &100
STA cblock+6
\ set end addr
LDA #(buffer+9) AND &FF
STA cblock+9
LDA #(buffer+9) DIV &100
STA cblock+10
\ zero top of 32-bit addrs
LDA #0
STA cblock+7
STA cblock+8
STA cblock+11
STA cblock+12
LDX #cblock AND &FF
LDY #cblock DIV &100
LDA #ASC"B":JSR OSASCI \ DEBUG=rx block req
JSR rx
TXA
BMI chkblkreq
:
JSR abortsend
BRK
EQUB &42 \ =no scout
EQUS "Block request timeout"
EQUB 0
:
.chkblkreq
\ check is block request
LDA buffer
CMP #OP_BLKREQ
BEQ blkreqok
JSR abortsend
BRK
EQUB 100 \ TODO
EQUS "Expected block request"
EQUB 0
:
.blkreqok
LDX #(cblock+9) AND &FF
LDY #(cblock+9) DIV &100
JSR wrdouble:JSR OSNEWL
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR sbcdouble
LDX #(cblock+9) AND &FF
LDY #(cblock+9) DIV &100
JSR wrdouble:JSR OSNEWL
LDA #9
STA cblock+5
LDA #0
STA cblock+6
STA cblock+7
STA cblock+8
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR sbcdouble
LDX #(cblock+9) AND &FF
LDY #(cblock+9) DIV &100
JSR wrdouble:JSR OSNEWL
LDA #0
STA cblock+5
STA cblock+6
STA cblock+7
STA cblock+8
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR cmpdouble
BEQ equal
BMI more
LDA #ASC"<"
JMP okdone
.more
LDA #ASC">"
JMP okdone
.equal
LDA #ASC"="
:
.okdone
JSR OSASCI
JSR abortsend
LDY #0
.loop
LDA okmsg,Y
INY
JSR OSASCI
CMP #13
BNE loop
RTS
.okmsg
EQUS "OK so far!"
EQUB 13
:
.abortsend
LDA #0 \ =close
LDY fhandle
JSR OSFIND
JMP scratchrestore \ JMP>RTS
:
.sbcdouble
STX scratch
STY scratch+1
SEC
LDY #4
LDA (scratch),Y
LDY #0
SBC (scratch),Y
LDY #4
STA (scratch),Y
INY
LDA (scratch),Y
LDY #1
SBC (scratch),Y
LDY #5
STA (scratch),Y
INY
LDA (scratch),Y
LDY #2
SBC (scratch),Y
LDY #6
STA (scratch),Y
INY
LDA (scratch),Y
LDY #3
SBC (scratch),Y
LDY #7
STA (scratch),Y
RTS
:
.cmpdouble
STX scratch
STY scratch+1
LDY #4
LDA (scratch),Y
LDY #0
CMP (scratch),Y
BNE cmpdone
LDY #5
LDA (scratch),Y
LDY #1
CMP (scratch),Y
BNE cmpdone
LDY #6
LDA (scratch),Y
LDY #2
CMP (scratch),Y
BNE cmpdone
LDY #7
LDA (scratch),Y
LDY #3
CMP (scratch),Y
.cmpdone
RTS
:
.neterror
\ calculate offset of this error
\ in the message addr table
STX errorcode
JSR scratchrestore
LDX errorcode
CPX #&40
BEQ linejamerr
CPX #&41
BEQ handshkerr
CPX #&42
BEQ noscouterr
CPX #&43
BEQ noclockerr
CPX #&44
BEQ badtxblkerr
BRK
EQUB 255
EQUS "Unknown error"
EQUB 0
.linejamerr
BRK
EQUB &40
EQUS "Line jammed"
EQUB 0
.handshkerr
BRK
EQUB &41
EQUS "Net error"
EQUB 0
.noscouterr
BRK
EQUB &42
EQUS "Not listening"
EQUB 0
.noclockerr
BRK
EQUB &43
EQUS "No clock"
EQUB 0
.badtxblkerr
BRK
EQUB &44
EQUS "Bad control block"
EQUB 0
:
.scratchrestore
\ restore scratch bytes assuming
\ they're at the top of the
\ stack, underneath the return
\ address added by a JSR
\ Entry - stack as above
\ Exit  - AXY undefined
\ pop my return addr to YX
PLA
TAY
PLA
TAX
\ restore scratch
PLA
STA scratch+1
PLA
STA scratch
\ push my return addr
TXA
PHA
TYA
PHA
RTS
:
\ --- TX ---
:
.tx
\ Entry - YX=cblock
\ Exit  - X=0-success else err#
:
\ preserve scratch on stack
LDA scratch
PHA
LDA scratch+1
PHA
\ XY address in scratch
STX scratch
STY scratch+1
:
\ calculate timeout
LDA #txtimeout% AND &FF
STA timeout
LDA #(txtimeout% AND &FF00) DIV &100
STA timeout+1
\ timeout < 655.35s so +2/3/4=0
LDA #0
STA timeout+2
STA timeout+3
STA timeout+4
JSR set_timeout
:
.tx_start
LDA #&80 \ LSb=not started
LDY #0
STA (scratch),Y
LDA #&10 \ =transmit
LDX scratch
LDY scratch+1
JSR OSWORD
LDY #0
LDA (scratch),Y
BEQ tx_start
:
.tx_poll
\ poll for completion
LDA #&32 \ =poll transmit
JSR OSBYTE
TXA
BMI tx_poll
CPX #&41 \ network error
BEQ tx_retry_check
CPX #&42 \ not listening
BEQ tx_retry_check
\ either success or fatal error
JMP scratch_restore \ JMP>RTS
:
.tx_retry_check
PHA
JSR chk_timeout
PLA
BCC tx_start \ retry TX
\ timed out
TAX \ reply in X
JMP scratch_restore \ JMP>RTS
:
\ --- RX ---
:
.rx
\ Entry - YX=cblock
\  +0/1 will be initialised
\ Exit  - X=MSb-success
:
\ preserve scratch on stack
LDA scratch
PHA
LDA scratch+1
PHA
\ XY address in scratch
STX scratch
STY scratch+1
:
LDA #0
LDY #0
STA (scratch),Y \ for cblk num
LDA #&7F \ for control byte
INY
STA (scratch),Y
LDA #&11 \ =receive
\ X=scratch, above
LDY scratch+1
JSR OSWORD
:
\ calculate timeout
LDA #rxtimeout% AND &FF
STA timeout
LDA #(rxtimeout% AND &FF00) DIV &100
STA timeout+1
\ timeout < 655.35s so +2/3/4=0
LDA #0
STA timeout+2
STA timeout+3
STA timeout+4
JSR set_timeout
:
.rx_poll
\ poll for reception
LDY #0
LDA (scratch),Y
TAX
LDA #&33 \ =poll receive
JSR OSBYTE
TXA
BMI rx_read
:
\ no data received
JSR chk_timeout
BCC rx_poll \ retry poll
\ timed out
LDY #0
LDA (scratch),Y
TAX
LDA #&34 \ =delete RX block
JSR OSBYTE
LDX #0 \ !MSb => not received
JMP scratch_restore
:
.rx_read
\ received message
LDA #&11 \ =read RX block
LDX scratch
LDY scratch+1
JSR OSWORD
LDX #&80 \ MSb => received
:
.scratch_restore
PLA
STA scratch+1
PLA
STA scratch
RTS
:
.get_time
\ Get interval timer into
\ buffer.
\ Exit  - AXY undefined
LDA #3 \ read interval timer
LDX #now MOD 256
LDY #now DIV 256
JMP OSWORD
\ RTS back to caller
:
.set_timeout
\ Entry - length of time in
\         timeout buffer
\ Exit  _ time buffer updated to
\         current time; timeout
\         buffer added to
\         current time
\         AXY undefined
JSR get_time
CLC
LDA now
ADC timeout
STA timeout
LDA now+1
ADC timeout+1
STA timeout+1
LDA now+2
ADC timeout+2
STA timeout+2
LDA now+3
ADC timeout+3
STA timeout+3
LDA now+4
ADC timeout+4
STA timeout+4
RTS
:
.chk_timeout
\ get interval timer into buffer
\ and compare with timeout
\ Exit - C=timeout reached
\        AXY undefined
JSR get_time
LDA now+4
CMP timeout+4
BNE timeout_checked
LDA now+3
CMP timeout+3
BNE timeout_checked
LDA now+2
CMP timeout+2
BNE timeout_checked
LDA now+1
CMP timeout+1
BNE timeout_checked
LDA now
CMP timeout
.timeout_checked
RTS
:
\ --- variable storage ---
:
.fhandle
EQUB 0
::
.errorcode
EQUB 0
:
.peeraddr
EQUW 0 \ stn.net
:
.fnameaddr
EQUW 0
:
.xfrbytes
EQUD 0
:
.now
\ get_time fetches timer to here
EQUB 0
EQUB 0
EQUB 0
EQUB 0
EQUB 0
.timeout
\ expiry of timeout
EQUB 0
EQUB 0
EQUB 0
EQUB 0
EQUB 0
:
\ GENERAL ROUTINES
:
.wrdouble
STX scratch
STY scratch+1
LDX #0
LDY #3
.loop
LDA (scratch),Y
BNE wrdoublehex
CPX #0
BNE wrdoublehex
CPY #0
BNE skipwrdoublehex
.wrdoublehex
JSR wrhex
INX
.skipwrdoublehex
DEY
BPL loop
RTS
:
.wrhex
PHA
LSR A
LSR A
LSR A
LSR A
JSR wrnibble
PLA
AND #&0F
JMP wrnibble \ JMP>RTS
:
.wrnibble
SED
CMP #10
ADC #&30
CLD
JMP OSASCI \ JMP>RTS
:
.wrreg
PHA
LDA #ASC"("
JSR OSASCI
:
LDA #ASC"A"
JSR OSASCI
PLA
PHA
JSR wrhex
:
LDA #ASC"X"
JSR OSASCI
TXA
JSR wrhex
:
LDA #ASC"Y"
JSR OSASCI
TYA
JSR wrhex
:
LDA #ASC")"
JSR OSASCI
PLA
RTS
]
IF P%-code%>codebuf% THEN PRINT "Code overran target buffer: ";P%-code%;">";codebuf%;" bytes":STOP
NEXT
PRINT "Code assembled at &";~code%;"+";~P%-code%
ENDPROC
:
DEFFNtx_mc(station%,port%,buffer,len%)
LOCAL X%,Y%
cblock?1=port%
cblock!2=station%
cblock!4=buffer
cblock!8=buffer+len%
X%=cblock
Y%=cblock DIV &100
=(USR(tx) AND &FF00) DIV &100
:
DEFFNrx_mc(station%,port%,buffer,maxlen%)
REM receive packet return #bytes
:
LOCAL X%,Y%,U%
cblock?2=port%
cblock!3=station%
cblock!5=buffer
cblock!9=buffer+maxlen%
X%=cblock
Y%=cblock DIV &100
IF (USR(rx) AND &8000)=0 THEN =-1
=cblock!9-cblock!5
:
DEFFNtx_bas(station%,port%,buffer,len%)
REM transmit packet
LOCAL A%,X%,Y%,delay%,result%,nonfatal%
:
timeout%=TIME+polltimeout%
REM loop until timeout or fatal
REPEAT
:
REM set up control block
cblock?1=port%
cblock!2=station%
cblock!4=buffer
cblock!8=buffer+len%
REM start transmission
A%=&10:REM transmit
X%=cblock
Y%=cblock DIV 256
REM loop until started
REPEAT
?cblock=&80
CALL OSWORD
UNTIL ?cblock<>0
:
REM poll for completion
REPEAT
A%=&32:REM poll transmit
result%=(USR(OSBYTE) AND &FF00) DIV &100
UNTIL (result% AND &80)=0
:
nonfatal%=(result%=&41 OR result%=&42)
UNTIL (NOT nonfatal%) OR TIME>=timeout%
=result%
:
DEFFNrx_bas(station%,port%,buffer,maxlen%)
REM receive packet return #bytes
:
LOCAL A%,X%,Y%
:
REM set up control block
?cblock=0:REM for cblock num
cblock?1=&7F
cblock?2=port%
cblock!3=station%
cblock!5=buffer
cblock!9=buffer+maxlen%
REM listen
A%=&11:REM receive
X%=cblock
Y%=cblock DIV 256
CALL OSWORD
:
REM poll for reception
A%=&33:REM poll receive
X%=?cblock:PRINT "P";~X%;
timeout%=TIME+polltimeout%
REPEAT
result%=(USR(OSBYTE) AND &8000)
UNTIL result%<>0 OR TIME>=timeout%
IF result%=0 THEN PRINT "Timed out waiting":A%=&34:X%=?cblock:CALL OSBYTE:=-1
:
A%=&11:REM receive
X%=cblock
Y%=cblock DIV 256
REM ?cblock populated above
CALL OSWORD
=cblock!9-cblock!5
:
DEFPROCdelay(n%)
REM delay n% cs
LOCAL limit%
limit%=TIME+n%
REPEAT UNTIL TIME>=limit%
ENDPROC
:
DEFFNmin(a,b)
IF a<=b THEN =a ELSE =b
:
DEFFNstation(station%)
LOCAL s$
s$=""
IF (station% DIV 256)<>0 THEN s$=STR$(station% DIV 256)+"."
=s$+STR$(station% MOD 256)
:
DEFFNneterror(err%)
IF err%=&40 THEN ="Line jammed"
IF err%=&41 THEN ="Net error"
IF err%=&42 THEN ="Not listening"
IF err%=&43 THEN ="No clock"
IF err%=&44 THEN ="Bad control block"
="ERR#"+STR$~err%
:
DEFPROCpkttest
LOCAL station%,key$
PRINT "PACKET TEST"
REPEAT
INPUT "Remote station? "station%
UNTIL station%>1 AND station%<255
:
REPEAT
PRINT "T(ransmit) or R(eceive): ";
REPEAT
key$=GET$
valid%=INSTR("TR",key$)<>0
IF NOT valid% THEN VDU 7
UNTIL valid%
PRINT key$
IF key$="T" THEN PROCtxtest(station%)
IF key$="R" THEN PROCrxtest(station%)
UNTIL FALSE
ENDPROC
:
DEFFNtx(station%,port%,buffer,len%)
REM PRINT "TX ";FNstation(station%);":";port%;" @ &";~buffer;"+";~len%
=FNtx_mc(station%,port%,buffer,len%)
:
DEFFNrx(station%,port%,buffer,maxlen%)
REM PRINT "RX ";FNstation(station%);":";port%;" @ &";~buffer;"+";~maxlen%
=FNrx_mc(station%,port%,buffer,maxlen%)
:
DEFPROCtxtest(station%)
LOCAL result%
$buffer="to:"+STR$(station%)
result%=FNtx(station%,port%+1,buffer,LEN($buffer)+1)
PRINT "Result=&";~result%
ENDPROC
:
DEFPROCrxtest(station%)
LOCAL bytes%
bytes%=FNrx(station%,port%+1,buffer,buflen)
PRINT "Bytes=";bytes%
IF bytes%<>-1 THEN PRINT "Received:<";$buffer;">"
ENDPROC
