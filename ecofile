*BASIC
NEW
AUTO
REM>Ecofile
:
OSWORD=&FFF1
OSBYTE=&FFF4
OSFILE=&FFDD
OSGBPB=&FFD1
OSFIND=&FFCE
OSASCI=&FFE3
OSNEWL=&FFE7
OSWRCH=&FFEE
:
OP_FILEINFO=&01
OP_BLKREQ=&81
OP_BLKSND=&02
:
codebuf%=3000
DIM code% codebuf%
scratch=&70
scratchsize=5
polltimeout=500
txtimeout%=500
rxtimeout%=500
:
polldelay%=10
polltimeout%=500
maxxfr=256:REM in single packet
readbytes=maxxfr:REM bytes read by OSGBPB must be >=maxxfr
buflen=readbytes+13:REM +13 for OSGBPB param block
srv_port=100
cli_port=101
DIM cblock 13,buffer buflen
:
DIM F 100,S 20
:
PROCassemble
:
REM test routine
$F="T3"
!S=81
S!2=F
X%=S
Y%=S DIV 256
PRINT "Receiving..."
PRINT ~USR(receive)
END
:
REPEAT
INPUT "T(ransmit), R(eceive) or P(kttest)? " dir$
UNTIL INSTR("TRP",dir$)<>0
:
IF dir$="P" THEN PROCpkttest
:
REPEAT
INPUT "Remote station (0=any)? " station%
UNTIL station%>=0 AND station%<=254
:
IF dir$="T" THEN PROCtransmit
IF dir$="R" THEN PROCreceive
PRINT "End program"
END
:
DEFPROCtransmit
LOCAL filenamelen%,result%
INPUT "Filename? " filename$
IF 18+LEN(filename$)+1>=buflen THEN PRINT "Filename too long":STOP
:
$(buffer+18)=filename$
!buffer=buffer+18
A%=5
X%=buffer MOD 256
Y%=buffer DIV 256
result%=USR(OSFILE) AND &FF
IF result%<>1 THEN PRINT "File error":STOP
len%=buffer!10
PRINT filename$;" ";~buffer!2;" ";~buffer!6;" ";~len%
:
?buffer=OP_FILEINFO
buffer?1=cli_port
result%=FNtx(station%,srv_port,buffer,18+LEN(filename$)+1)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
:
A%=64:REM open for input
X%=(buffer+18) MOD 256
Y%=(buffer+18) DIV 256
fh%=USR(OSFIND) AND &FF
IF fh%=0 THEN PRINT "Error opening file":STOP
:
currpos%=0
REPEAT
REPEAT
bytes%=FNrx(station%,cli_port,buffer,9)
IF bytes%<>9 THEN PRINT "Illegal next block":STOP
IF ?buffer<>OP_BLKREQ THEN PRINT "Unexpected operation ";~?buffer
UNTIL ?buffer=OP_BLKREQ
PRINT ;~buffer!1;" ";
IF buffer!1<>currpos% THEN PRINT "Error - we're expecting &";~currpos%:STOP
:
filebytes%=FNmin(maxxfr,len%-currpos%)
?buffer=fh%
buffer!1=buffer+13
filebytes%=FNmin(maxxfr,len%-currpos%)
buffer!5=filebytes%
A%=4:REM read at curr pos
X%=buffer MOD 256
Y%=buffer DIV 256
IF (USR(OSGBPB) AND &1000000)<>0 THEN PRINT "Error reading file":STOP
:
buffer?8=OP_BLKSND
buffer!9=currpos%
result%=FNtx(station%,srv_port,buffer+8,filebytes%+5)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
currpos%=currpos%+filebytes%
UNTIL currpos%>=len%
PRINT "=";~currpos%
:
A%=0
Y%=fh%
CALL OSFIND
ENDPROC
:
DEFPROCreceive
LOCAL bytes%
REPEAT
PRINT "Waiting for TX start..."
bytes%=FNrx(station%,srv_port,buffer,buflen)
IF bytes%<0 THEN PRINT "Nothing received"
UNTIL bytes%>=0
IF bytes%<20 THEN PRINT "Illegal info block (too small)":STOP
IF ?buffer<>OP_FILEINFO THEN PRINT "Unexpected operation ";~?buffer:STOP
:
station%=cblock!3 AND &FFFF
port%=buffer?1
name$=$(buffer+18)
load%=buffer!2
exec%=buffer!6
len%=buffer!10
PRINT FNstation(station%);":";port%;" ";name$;" ";~load%;" ";~exec%;" ";~len%
:
A%=128:REM open for output
X%=(buffer+17) MOD 256
Y%=(buffer+17) DIV 256
fh%=USR(OSFIND) AND &FF
IF fh%=0 THEN PRINT "Error opening file":STOP
:
currpos%=0
REPEAT
PRINT ;~currpos%;" ";
?buffer=OP_BLKREQ
buffer!1=currpos%
buffer!5=maxxfr
result%=FNtx(station%,port%,buffer,9)
IF result%<>0 THEN PRINT FNneterror(result%):STOP
:
bytes%=FNrx(station%,srv_port,buffer+8,maxxfr+5)
IF buffer?8<>OP_BLKSND THEN PRINT "Invalid block type received":STOP
IF buffer!9<>currpos% THEN PRINT "Incorrect position":STOP
IF bytes%-5>len%-currpos% THEN PRINT "Oversize block":STOP
:
?buffer=fh%
buffer!1=buffer+13
buffer!5=bytes%-5
A%=2:REM append
X%=buffer MOD 256
Y%=buffer DIV 256
IF (USR(OSGBPB) AND &1000000)<>0 THEN PRINT "Error writing file":STOP
:
currpos%=currpos%+bytes%-5
UNTIL currpos%>=len%
PRINT "=";~currpos%
:
A%=0
Y%=fh%
CALL OSFIND
:
REM write file metadata
$(buffer+18)=name$
!buffer=buffer+18
buffer!2=load%
A%=2:REM write load addr
X%=buffer MOD 256
Y%=buffer DIV 256
CALL OSFILE
A%=3:REM write exec addr
buffer!6=exec%
CALL OSFILE
:
ENDPROC
:
DEFPROCassemble
FOR pass%=0 TO 1
P%=code%
[ OPT pass%*2
\ --- SEND ---
:
.send
\ Entry-
\   YX=sendblk addr,
\   sendblk+0=dest stn,
\          +2=filename addr
\ Exit - AXY=undefined
:
\ SETUP AND GET PARAMS
:
\ save scratch
LDA scratch
PHA
LDA scratch+1
PHA
LDA scratch+2
PHA
LDA scratch+3
PHA
\ XY in scratch
STX scratch
STY scratch+1
:
\ store peer address
LDY #0
LDA (scratch),Y
STA peer
INY
LDA (scratch),Y
STA peer+1
\ store filename addr and in
\ start of buffer for OSGBPB,
\ below
INY
LDA (scratch),Y
STA fnameaddr
STA buffer
INY
LDA (scratch),Y
STA fnameaddr+1
STA buffer+1
:
\ GET FILE INFORMATION
:
LDA #5 \ =read info for file
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSFILE
CMP #1 \ =file found
BEQ savefilelen
\ not found
JSR scratchrestore
BRK
EQUB 214 \ =Not found
EQUS "Not found"
EQUB 0
:
.savefilelen
JSR savefilelen
\ print and copy leaf part of
\ filename into buffer for
\ transmission
:
LDA fnameaddr
STA scratch
LDA fnameaddr+1
STA scratch+1
:
\ find end of filename
LDX #0 \ index after last dot
LDY #0 \ current index
.loop
LDA (scratch),Y
INY
CMP #13 \ =CR
BEQ saveleafname
CMP #ASC"."
BNE loop
TYA \ save position after dot
TAX
JMP loop
:
.saveleafname
\ copy leaf part of filename
TXA
TAY
LDX #0 \ pos in leaf
.loop
LDA (scratch),Y
STA buffer+18,X
INX
CMP #13 \ =CR
BEQ printtxmeta
JSR OSASCI
INY
CPX #10 \ limit to 10 chars
BCC loop
:
.truncleafname
LDA #13 \ =CR
STA buffer+18,X
:
.printtxmeta
\ store len on stack
TXA
PHA
\ print attributes
JSR printmeta
:
\ BUILD + SEND FILE HEADER
:
\ populate buffer to send;
\ we can use the OSFILE param
\ block but just change the
\ first two bytes and append
\ the filename
:
LDA #OP_FILEINFO
STA buffer
LDA #cli_port
STA buffer+1
:
\ build tx cblock
:
\ store size of buffer in cblock
\ and add start addr to get end
\ (size = op/port (2) + meta
\ data (16) + filename len)
PLA
CLC
ADC #(buffer+19) AND &FF
STA cblock+8 \ buffer end addr
LDA #(buffer+19) DIV &100
ADC #0
STA cblock+9
\ top bytes blanked below
:
\ store dest port
LDA #srv_port
STA cblock+1
\ copy dest addr
LDA peer
STA cblock+2
LDA peer+1
STA cblock+3
:
\ put buffer addr in cblock
LDA #buffer AND &FF
STA cblock+4 \ buffer start addr
LDA #buffer DIV &100
STA cblock+5
\ never >64K so no need to do
\ carry - zero top of both
\ 32-bit addrs
LDA #0
STA cblock+6 \ start+2
STA cblock+7
STA cblock+10 \ end+2
STA cblock+11
:
\ do tx
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR tx
TXA
BEQ openin \ X=1-success
JMP neterror
:
\ PREPARE FOR TX FILE BLOCKS
:
.openin
LDA #&40 \ =openin
LDX fnameaddr
LDY fnameaddr+1
JSR OSFIND
STA fhandle
TAX
BNE openinok
\ open in error
JSR scratchrestore
BRK
EQUB 214 \ =Not found
EQUS "Not found"
EQUB 0
:
.openinok
JSR initfilemeta
STA buffused \ word
STA buffused+1
:
\ MAIN BLOCK TRANSFER LOOP
:
.xfrloop
:
\ check if any bytes left in the
\ buffer after sending the
\ previous packet - if there
\ are, we just use those
LDA buffused
BNE getblkreq
LDA buffused+1
BNE getblkreq
:
\ buffer empty so read in
\ another block of maxxfr bytes
:
\ build OSGBPB block
:
LDA fhandle
STA buffer
:
\ buffer to read bytes from file
\ after OSGBPB param block at
\ buffer+13 (which leaves space
\ for block request rx + block
\ send tx, too)
LDA #(buffer+13) AND &FF
STA buffer+1
LDA #(buffer+13) DIV &100
STA buffer+2
\ max bytes to read (word) to
\ buffer+5
LDA #readbytes AND &FF
STA buffer+5
LDA #readbytes DIV &100
STA buffer+6
\ zero top 2 bytes of 32-bit
\ addrs
LDA #0
STA buffer+3 \ buffer addr+2
STA buffer+4
STA buffer+7 \ readbytes addr+2
STA buffer+8
:
\ remaining bytes to buffer+9
LDY #3
.loop
LDA remain,Y
STA buffer+9,Y
DEY
BPL loop
:
\ min(readbytes,remain) is bytes
\ to read
LDX #(buffer+5) AND &FF
LDY #(buffer+5) DIV &100
JSR mindbl \ => buffer+5
\ update buffused with bytes to
\ read; we assume the read will
\ be successful - if not, we
\ abort anyway (this field is
\ overwritten by the read)
LDY #3
.loop
LDA buffer+5,Y
STA buffused,Y
DEY
BPL loop
:
LDA #4 \ =read at current pos
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSGBPB
BCC getblkreq \ =success
\ error reading file
JMP cleanup
BRK
EQUB 189 \ =Access violation
EQUS "File read error"
EQUB 0
:
.getblkreq
:
\ BLOCK REQUEST RX
:
\ print next byte expected to tx
\ and in the blkreq
LDA #13
JSR OSWRCH \ CR but not LF
LDX #currpos AND &FF
LDY #currpos DIV &100
JSR wrdbl
:
\ check if there is anything
\ left to transfer
LDY #3
.loop
LDA remain,Y
BNE waitblkreq \ <>0=more
DEY
BPL loop
:
.done
\ finished transfer (also use
\ for receive)
:
\ close the file
JSR cleanup
LDY #0
.loop
LDA okmsg,Y
INY
JSR OSASCI
CMP #13
BNE loop
RTS
.okmsg
EQUS "Done"
EQUB 13
:
.waitblkreq
\ set up rx cblock
LDA #cli_port
STA cblock+2
\ copy sender addr
LDA peer
STA cblock+3
LDA peer+1
STA cblock+4
:
.fileinfocblock
\ set start addr
LDA #buffer AND &FF
STA cblock+5
LDA #buffer DIV &100
STA cblock+6
\ set end addr - blkreq is
\ always 9 bytes
LDA #(buffer+9) AND &FF
STA cblock+9
LDA #(buffer+9) DIV &100
STA cblock+10
\ zero top of 32-bit addrs
LDA #0
STA cblock+7 \ start addr+2
STA cblock+8
STA cblock+11 \ end addr+2
STA cblock+12
:
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR rx
TXA
BMI chkblkreq \ X[7]=success
\ no block request received
JSR cleanup
BRK
EQUB &42 \ =no scout
EQUS "Block request timeout"
EQUB 0
:
.chkblkreq
\ check is block request
LDA buffer
CMP #OP_BLKREQ
BEQ rcvblkreq
\ incorrect packet operation
JSR cleanup
BRK
EQUB 217 \ =CFS Header
EQUS "Block request?"
EQUB 0
:
.rcvblkreq
\ end-start=bytes received
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR sbcdblsec \ => cblock+5
\ confirm size=9
LDA #9
STA cblock+9
LDA #0
STA cblock+10
STA cblock+11
STA cblock+12
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR cmpdbl
BEQ calcxfr
\ size<>9
JSR cleanup
BRK
EQUB 20 \ =Too big
EQUS "Block request size"
EQUB 0
:
.calcxfr
\ bytes to transfer is
\ min(buffused,maxxfr); buffused
\ is left in buffer+5, above
LDA buffused
STA buffer+9
LDA buffused+1
STA buffer+10
LDA #0 \ pad buffused word
STA buffer+11
STA buffer+12
:
LDX #(buffer+5) AND &FF
LDY #(buffer+5) DIV &100
JSR mindbl \ => buffer+5
\ copy bytes to transfer to end
\ addr (we will add start addr
\ later)
LDY #3
.loop
LDA buffer+5,Y
STA cblock+8,Y
DEY
BPL loop
:
\ we update remain, currpos and
\ buffused before we actually do
\ the transmission as they're in
\ handy places
:
\ update bytes remaining to be
\ transferred
LDY #3
.loop
LDA remain,Y
STA buffer+9,Y
DEY
BPL loop
\ do subtraction
LDX #(buffer+5) AND &FF
LDY #(buffer+5) DIV &100
JSR sbcdblsec \ => buffer+5
LDY #3
.loop
LDA buffer+5,Y
STA remain,Y
DEY
BPL loop
:
\ copy expected pos into
\ buffer+5 and compare with
\ recv'd
LDY #3
.loop
LDA currpos,Y
STA buffer+5,Y
DEY
BPL loop
LDX #(buffer+1) AND &FF
LDY #(buffer+1) DIV &100
JSR cmpdbl
BEQ updcurrpos \ =same
\ offset mismatch
JSR cleanup
BRK
EQUB 218 \ =CFS Block
EQUS "Block offset"
EQUB 0
:
.updcurrpos
\ calculate new currpos
\ (buffer+5 = currpos)
\ bytes to be transferred to
\ buffer+9
LDA cblock+8
STA buffer+9
LDA cblock+9
STA buffer+10
LDA #0
STA buffer+11 \ pad word
STA buffer+12
\ do addition
LDX #(buffer+5) AND &FF
LDY #(buffer+5) DIV &100
JSR adcdblclc \ => buffer+9
\ update position
LDY #3
.loop
LDA buffer+9,Y
STA currpos,Y
DEY
BPL loop
:
\ update bytes left in buffer
SEC
LDA buffused
SBC cblock+8
STA buffused
LDA buffused+1
SBC cblock+9
STA buffused+1
:
\ save bytes being transferred
\ in buffer+5 so we can shuffle
\ the buffer memory later
LDA cblock+8
STA buffer+5
LDA cblock+9
STA buffer+6
:
\ build tx cblock
:
\ calculate start and end addrs
:
\ add size of header (5 bytes)
\ to len (cblock+8 contains len)
LDA #5
STA cblock+4
LDA #0
STA cblock+5
STA cblock+6
STA cblock+7
LDX #(cblock+4) AND &FF
LDY #(cblock+4) DIV &100
JSR adcdblclc \ => cblock+8
:
\ buffer start address
LDA #(buffer+8) AND &FF
STA cblock+4
LDA #(buffer+8) DIV &100
STA cblock+5
LDA #0
STA cblock+6
STA cblock+7
:
\ add to end address
LDX #(cblock+4) AND &FF
LDY #(cblock+4) DIV &100
JSR adcdblclc \ => cblock+8
:
\ store block type in buffer
LDA #OP_BLKSND
STA buffer+8
\ store offset at buffer+9 (just
\ before data read by OSGBPB at
\ buffer+13); use buffer+1 as
\ currpos has been updated
LDY #3
.loop
LDA buffer+1,Y
STA buffer+9,Y
DEY
BPL loop
:
\ store dest port
LDA #srv_port
STA cblock+1
\ copy dest addr
LDA peer
STA cblock+2
LDA peer+1
STA cblock+3
:
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR tx
TXA
BEQ shufflechk \ X=1-success
JMP neterror
:
.shufflechk
\ shuffle the untransmitted data
\ in the buffer to the start
\
\ we know the addrs here are
\ 16-bit so only use 2 bytes
:
\ skip this if we transferred
\ the entire buffer and no
\ shuffling required
LDA buffused
ORA buffused+1
BNE shufflebuff256
.jmpxfrloop
JMP xfrloop
:
.shufflebuff256
\ calculate the buffer src addr
\ (start after header + bytes
\ transferred) into scratch+0/1
LDA #ASC":":JSR OSASCI
CLC
LDA #(buffer+13) AND &FF
ADC buffer+5
STA scratch
LDA #(buffer+13) DIV &100
ADC buffer+6
STA scratch+1
:
\ set the buffer dst addr
\ (start after header) in
\ scratch+2/3
LDA #(buffer+13) AND &FF
STA scratch+2
LDA #(buffer+13) DIV &100
STA scratch+3
:
\ move the blocks of 256 bytes
\ (scratch+0/1)->(scratch+2/3)
LDX buffused+1
BEQ shufflebuff1
LDY #0
.loop
LDA (scratch),Y
STA (scratch+2),Y
INY
BNE loop
INC scratch+1
INC scratch+3
DEX
BNE loop
:
.shufflebuff1
\ check there is still <256 to
\ move
LDX buffused
BEQ jmpxfrloop \ no
LDY #0
.loop
LDA (scratch),Y
STA (scratch+2),Y
INY
DEX
BNE loop
JMP xfrloop
:
\ RECEIVE
:
.receive
\ Entry-
\   YX=sendblk addr,
\   sendblk
\     +0=dest stn (0.0=any),
\     +2=filename addr (0=sent)
\ Exit - AXY=undefined
:
\ SETUP AND GET PARAMS
:
\ save scratch
LDA scratch
PHA
LDA scratch+1
PHA
LDA scratch+2
PHA
LDA scratch+3
PHA
\ XY in scratch
STX scratch
STY scratch+1
:
\ store peer address
LDY #0
LDA (scratch),Y
STA peer
INY
LDA (scratch),Y
STA peer+1
\ store filename addr and in
\ start of buffer for OSGBPB,
\ below
INY
LDA (scratch),Y
STA fnameaddr
INY
LDA (scratch),Y
STA fnameaddr+1
:
\ build RX cblock
:
LDA #srv_port
STA cblock+2
LDA peer
STA cblock+3
LDA peer+1
STA cblock+4
\ buffer start
LDA #buffer AND &FF
STA cblock+5
LDA #buffer DIV &100
STA cblock+6
\ buffer end - max is 29 (18
\ op/port/load/exec/len/attr +
\ 10 filename + CR)
LDA #(buffer+29) AND &FF
STA cblock+9
LDA #(buffer+29) DIV &100
STA cblock+10
\ zero pad top half of words
LDA #0
STA cblock+7
STA cblock+8
STA cblock+11
STA cblock+12
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR rx
TXA
BMI headerrcvd
BRK
EQUB &42
EQUS "Timeout"
EQUB 0
:
.headerrcvd
LDA buffer
CMP #OP_FILEINFO
BEQ rcvfileinfo
\ incorrect packet operation
JSR scratchrestore
BRK
EQUB 217 \ =CFS Header
EQUS "File info?"
EQUB 0
:
.rcvfileinfo
\ save peer details
LDA buffer+1
STA port
LDA cblock+3
STA peer
LDA cblock+4
STA peer+1
:
\ addr of received filename
\ (may override later)
LDA #(buffer+18) AND &FF
STA buffer
LDA #(buffer+18) DIV &100
STA buffer+1
:
LDY #0
.loop
LDA buffer+18,Y
CMP #13
BEQ headerdone
CMP #32
BCC invalidrecvname
CMP #127
BCS invalidrecvname
JSR OSASCI
INY
CPY #10
BCC loop
.invalidrecvname
BRK
EQUB 219 \ =CFS File?
EQUS "Invalid name"
EQUB 0
:
.headerdone
LDA #ASC"@"
JSR OSASCI
LDA peer+1
BEQ skipnet
JSR wrdec
LDA #ASC"."
JSR OSASCI
.skipnet
LDA peer
JSR wrdec
:
LDA fnameaddr
ORA fnameaddr+1
BEQ recvnamedone
LDA #ASC"-"
JSR OSASCI
LDA #ASC">"
JSR OSASCI
LDA fnameaddr
STA scratch
STA buffer \ for OSFILE
LDA fnameaddr+1
STA scratch+1
STA buffer+1
LDY #0
.loop
LDA (scratch),Y
CMP #13
BEQ recvnamedone
JSR OSASCI
INY
JMP loop
:
.recvnamedone
JSR printmeta
:
\ store currpos + remain
JSR initfilemeta
:
\ start+end addrs = 0
LDA #0
LDY #7
.loop
STA buffer+10,Y
DEY
BPL loop
:
LDA #0 \ =save
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSFILE
:
\ open file
LDA #&C0 \ =openup
LDX buffer
LDY buffer+1
JSR OSFIND
TAY
BNE openoutok
JSR scratchrestore
BRK
EQUB 214 \ =Not found
EQUS "File error"
EQUB 0
:
.openoutok
STA fhandle
:
\ BLOCK REQUEST
:
.rcvxfrloop
:
LDA #13 \ =CR
JSR OSWRCH \ CR but not LF
LDX #currpos AND &FF
LDY #currpos DIV &100
JSR wrdbl
:
\ if nothing left to transfer,
\ we're done, else request next
\ block
LDY #3
.loop
LDA remain,Y
BNE rcvreqblk
DEY
BPL loop
JMP done
:
.rcvreqblk
LDA #OP_BLKREQ
STA buffer
LDY #3
.loop
LDA currpos,Y
STA buffer+1,Y
DEY
BPL loop
LDA #maxxfr AND &FF
STA buffer+5
LDA #maxxfr DIV &100
STA buffer+6
LDA #0
STA buffer+7
STA buffer+8
\
LDA port
STA cblock+1
LDA peer
STA cblock+2
LDA peer+1
STA cblock+3
LDA #buffer AND &FF
STA cblock+4
LDA #buffer DIV &100
STA cblock+5
LDA #(buffer+9) AND &FF
STA cblock+8
LDA #(buffer+9) DIV &100
STA cblock+9
LDA #0
STA cblock+6
STA cblock+7
STA cblock+10
STA cblock+11
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR tx
TXA
BEQ blkreqok \ X=1-success
JMP neterror
:
.blkreqok
\ get block of file
LDA #srv_port
STA cblock+2
LDA peer
STA cblock+3
LDA peer+1
STA cblock+4
\ get to buffer+8 so we can put
\ a OSGBPB param block in front
LDA #(buffer+8) AND &FF
STA cblock+5
LDA #(buffer+8) DIV &100
STA cblock+6
LDA #(buffer+8+5+maxxfr) AND &FF
STA cblock+9
LDA #(buffer+8+5+maxxfr) DIV &100
STA cblock+10
LDA #0
STA cblock+7
STA cblock+8
STA cblock+11
STA cblock+12
LDX #cblock AND &FF
LDY #cblock DIV &100
JSR rx
TXA
BMI replyrecv
JSR cleanup
BRK
EQUB &42 \ =No scout
EQUS "Block send timeout"
EQUB 0
:
.replyrecv
\ check is block send
LDA buffer+8
CMP #OP_BLKSND
BEQ rcvblksnd
\ incorrect packet operation
JSR cleanup
BRK
EQUB 217 \ =CFS Header
EQUS "Block send?"
EQUB 0
:
.rcvblksnd
LDY #3
.loop
LDA currpos,Y
STA buffer+5,Y
DEY
BPL loop
LDX #(buffer+5) AND &FF
LDY #(buffer+5) DIV &100
JSR cmpdbl
BEQ rcvblkmatch
JSR cleanup
BRK
EQUB 218 \ =CFS Block
EQUS "Block offset"
EQUB 0
:
.rcvblkmatch
\ calculate bytes received
\ based on end-start
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR sbcdblsec \ => cblock+5
\ minus the 5 bytes for the
\ block send header
SEC
LDA cblock+5
SBC #5
STA cblock+5
LDA cblock+6
SBC #0
STA cblock+6
:
\ check is less than remain
LDY #3
.loop
LDA remain,Y
STA cblock+9,Y
DEY
BPL loop
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR cmpdbl
BPL rcvblksizeok
JSR cleanup
BRK
EQUB 100 \ TODO
EQUS "Block oversize"
EQUB 0
:
.rcvblksizeok
LDA fhandle
STA buffer
LDA #(buffer+13) AND &FF
STA buffer+1
LDA #(buffer+13) DIV &100
STA buffer+2
LDA cblock+5
STA buffer+5
LDA cblock+6
STA buffer+6
LDA #0
STA buffer+3
STA buffer+4
STA buffer+7
STA buffer+8
:
LDA #2 \ =append
LDX #buffer AND &FF
LDY #buffer DIV &100
JSR OSGBPB
BCC rcvupdcurrpos
JSR cleanup
BRK
EQUB 100 \ TODO
EQUS "Error writing file"
EQUB 0
:
.rcvupdcurrpos
LDY #3
.loop
LDA currpos,Y
STA cblock+9,Y
DEY
BPL loop
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR adcdblclc \ => cblock+9
LDY #3
.loop
LDA cblock+9,Y
STA currpos,Y
DEY
BPL loop
:
\ update remain
LDY #3
.loop
LDA remain,Y
STA cblock+9,Y
DEY
BPL loop
LDX #(cblock+5) AND &FF
LDY #(cblock+5) DIV &100
JSR sbcdblsec \ => cblock+1
LDY #3
.loop
LDA cblock+5,Y
STA remain,Y
DEY
BPL loop
:
JMP rcvxfrloop
:
.oksofar
LDY #0
.loop
LDA oksofarmsg,Y
JSR OSASCI
INY
CMP #13
BNE loop
JSR cleanup
RTS
.oksofarmsg
EQUS "OK so far"
EQUB 13
:
\ UTILITY ROUTINES
:
.cleanup
LDA #0 \ =close
LDY fhandle
JSR OSFIND
JMP scratchrestore \ JMP>RTS
:
.neterror
\ calculate offset of this error
\ in the message addr table
STX errorcode
JSR scratchrestore
LDX errorcode
CPX #&40
BEQ linejamerr
CPX #&41
BEQ handshkerr
CPX #&42
BEQ noscouterr
CPX #&43
BEQ noclockerr
CPX #&44
BEQ badtxblkerr
BRK
EQUB 255
EQUS "Unknown error"
EQUB 0
.linejamerr
BRK
EQUB &40
EQUS "Line jammed"
EQUB 0
.handshkerr
BRK
EQUB &41
EQUS "Net error"
EQUB 0
.noscouterr
BRK
EQUB &42
EQUS "Not listening"
EQUB 0
.noclockerr
BRK
EQUB &43
EQUS "No clock"
EQUB 0
.badtxblkerr
BRK
EQUB &44
EQUS "Bad control block"
EQUB 0
:
.scratchrestore
\ Restore scratch bytes assuming
\ they're at the top of the
\ stack, underneath the return
\ address added by a JSR.
\ Entry- stack as above
\ Exit -
\   AXY undefined,
\   Return addr + scratch bytes
\   removed from stack.
PLA
TAY
PLA
TAX
\ restore scratch
PLA
STA scratch+3
PLA
STA scratch+2
PLA
STA scratch+1
PLA
STA scratch
\ push my return addr
TXA
PHA
TYA
PHA
RTS
:
.printmeta
\ Print file metadata - header
\ is assumed to be in the
\ buffer.
:
\ print load, execute, len
:
\ space
LDA #ASC" "
JSR OSASCI
\ load addr
LDA #1
LDX #(buffer+2) AND &FF
LDY #(buffer+2) DIV &100
JSR wrdbl0 \ leading 0s
\ space
LDA #ASC" "
JSR OSASCI
\ exec addr
LDA #1
LDX #(buffer+6) AND &FF
LDY #(buffer+6) DIV &100
JSR wrdbl0 \ leading 0s
\ space
LDA #ASC" "
JSR OSASCI
\ len
LDX #(buffer+10) AND &FF
LDY #(buffer+10) DIV &100
JSR wrdbl \ no leading 0s
JMP OSNEWL \ JMP>RTS
:
.initfilemeta
\ Store length from OSFILE param
\ block as remain and initialise
\ currpos to 0.
\ Exit - A=0
LDY #3
.loop
LDA buffer+10,Y
STA remain,Y
DEY
BPL loop
:
LDA #0
STA currpos \ double
STA currpos+1
STA currpos+2
STA currpos+3
RTS
:
.wrdbl
\ As wrdbl0 but sets A=0 first.
LDA #0
\
.wrdbl0
\ Write 32-bit double in hex.
\ Entry-
\   YX=double addr,
\   A=0/1 strip/print leading 0s
\ Exit -
\   AXY undefined
LSR A \ A->C
LDA scratch
PHA
LDA scratch+1
PHA
STX scratch
STY scratch+1
LDA #0 \ recover C->A
ROL A
TAX \ leading 0s flag
LDY #3 \ byte #; start at MSB
.loop
LDA (scratch),Y
BNE wrdblhex \ <>0 - write
CPX #0 \ leading zeroes?
BNE wrdblhex \ no - write
CPY #0 \ last digit?
BNE skipwrdblhex \ no - skip
.wrdblhex
JSR wrbyte
INX \ set not in leading zeros
.skipwrdblhex
DEY \ move to next byte MSB->LSB
BPL loop
PLA
STA scratch+1
PLA
STA scratch
RTS
:
.wrbyte
\ Write a single hex byte.
\ Entry- A=byte
\ Exit - AXY preserved
PHA
LSR A \ shift high nibble to low
LSR A
LSR A
LSR A
JSR wrnibble
PLA
PHA
AND #&0F \ get low nibble
JSR wrnibble
PLA
RTS
:
.wrnibble
\ Write a single hex digit.
\ Entry- A[0-3]=nibble,
\         [4-7]=must be 0
\ Exit - AXY undefined
PHP
SED
CMP #10 \ C=(>=&A)
ADC #ASC"0" \ C=>+&10=>"ABCDEF"
PLP
JMP OSASCI \ JMP>RTS
:
.wrdec
\ As wrdec0 but sets X=0.
LDX #0
:
.wrdec0
\ Write decimal digit in A
\ Entry-
\   A=value,
\   X=0/1 strip/print leading 0s
\ Exit -
\   AXY undefined
PHA
SEC
LDX #0 \ in leading 0s
LDY #&FF
.loop
INY
SBC #100
BCS loop
JSR wrdecdigit
CLC
ADC #100
LDY #&FF
.loop
INY
SBC #10
BCS loop
JSR wrdecdigit
CLC
ADC #10+ASC"0"
JSR OSASCI
PLA
RTS
:
.wrdecdigit
PHA
TYA
BNE wrdecdigitdo
CPX #0
BEQ skipdecdigit
.wrdecdigitdo
ORA #ASC"0"
JSR OSASCI
INX
.skipdecdigit
PLA
RTS
:
\ --- TX ---
:
.tx
\ Transmit an Econet packet;
\ wrapper around OSWORD &10 but
\ handles polling transmission.
\ Entry-
\   YX=cblock addr,
\   cblock as OSWORD except +0
\   will be initialised.
\ Exit - X=0-success else err#
:
\ preserve scratch on stack
LDA scratch
PHA
LDA scratch+1
PHA
\ XY address in scratch
STX scratch
STY scratch+1
:
\ calculate timeout
LDA #txtimeout% AND &FF
STA timeout
LDA #(txtimeout% AND &FF00) DIV &100
STA timeout+1
\ timeout < 655.35s so +2/3/4=0
LDA #0
STA timeout+2
STA timeout+3
STA timeout+4
JSR set_timeout
:
.tx_start
LDA #&80 \ LSb=not started
LDY #0
STA (scratch),Y
LDA #&10 \ =transmit
LDX scratch
LDY scratch+1
JSR OSWORD
LDY #0
LDA (scratch),Y
BEQ tx_start
:
.tx_poll
\ poll for completion
LDA #&32 \ =poll transmit
JSR OSBYTE
TXA
BMI tx_poll
CPX #&41 \ network error
BEQ tx_retry_check
CPX #&42 \ not listening
BEQ tx_retry_check
\ either success or fatal error
JMP scratch_restore \ JMP>RTS
:
.tx_retry_check
PHA
JSR chk_timeout
PLA
BCC tx_start \ retry TX
\ timed out
TAX \ reply in X
JMP scratch_restore \ JMP>RTS
:
\ --- RX ---
:
.rx
\ Receive an Econet packet;
\ wrapper around OSWORD &11 but
\ handles polling, timeout and
\ read or delete.
\ Entry-
\   YX=cblock addr
\   cblock as OSWORD except +0/1
\   will be initialised.
\ Exit- X[7]=success
:
\ preserve scratch on stack
LDA scratch
PHA
LDA scratch+1
PHA
\ XY address in scratch
STX scratch
STY scratch+1
:
LDA #0
LDY #0
STA (scratch),Y \ for cblk num
LDA #&7F \ for control byte
INY
STA (scratch),Y
LDA #&11 \ =receive
\ X=scratch, above
LDY scratch+1
JSR OSWORD
:
\ calculate timeout
LDA #rxtimeout% AND &FF
STA timeout
LDA #(rxtimeout% AND &FF00) DIV &100
STA timeout+1
\ timeout < 655.35s so +2/3/4=0
LDA #0
STA timeout+2
STA timeout+3
STA timeout+4
JSR set_timeout
:
.rx_poll
\ poll for reception
LDY #0
LDA (scratch),Y
TAX
LDA #&33 \ =poll receive
JSR OSBYTE
TXA
BMI rx_read
:
\ no data received
JSR chk_timeout
BCC rx_poll \ retry poll
\ timed out
LDY #0
LDA (scratch),Y
TAX
LDA #&34 \ =delete RX block
JSR OSBYTE
LDX #0 \ !MSb => not received
JMP scratch_restore
:
.rx_read
\ received message
LDA #&11 \ =read RX block
LDX scratch
LDY scratch+1
JSR OSWORD
LDX #&80 \ MSb => received
:
.scratch_restore
PLA
STA scratch+1
PLA
STA scratch
RTS
:
.get_time
\ Get interval timer into
\ buffer.
\ Exit  - AXY undefined
LDA #3 \ =read interval timer
LDX #now AND &FF
LDY #now DIV &100
JMP OSWORD \ JMP>RTS
:
.set_timeout
\ Set timeout to now + length of
\ timeout in timeout buffer.
\ Entry-
\   Timeout len in timeout
\   buffer.
\ Exit _
\   AXY undefined,
\   now buffer overwritten and
\   timeout buffer updated to
\   timeout len + now.
JSR get_time
CLC
LDY #0
PHP
.loop
PLP
LDA now,Y
ADC timeout,Y
STA timeout,Y
PHP
INY
CPY #5
BNE loop
PLP
RTS
:
.chk_timeout
\ Check if timeout (set by
\ set_timeout) has been reached.
\ Entry- none
\ Exit -
\   C=timeout reached,
\   AXY undefined
JSR get_time
LDY #4
.loop
LDA now,Y
CMP timeout,Y
\ if not same, stop here - C
\ will indicate if reached
BNE timeout_checked
DEY
BPL loop
.timeout_checked
RTS
:
.adcdblclc
\ As adcdbl but sets C=0 first.
CLC
.adcdbl
\ Add 32-bit doubles Q=Q+P
\ Entry-
\   YX=block addr,C=carry
\   block+0-3=P,+4-7=Q
\ Exit  -
\   AXY=undefined,CZN=as ADC,
\   block+0-3 unchanged,
\        +4-7=Q+P,
\   Overwrites scratch.
STX scratch
STY scratch+1
LDY #4
.loop
LDA (scratch),Y get byte in Q
DEY \ move to same byte in P
DEY
DEY
DEY
ADC (scratch),Y
PHP
INY \ back to same byte in Q
INY
INY
INY
STA (scratch),Y
CPY #7 \ finished
BEQ adcdbldone
INY \ move to next byte in Q
PLP
JMP loop
.adcdbldone
PLP
RTS
:
.sbcdblsec
\ As sbcdbl but sets C=1 (= no
\ borrow).
SEC
.sbcdbl
\ Subtract 32-bit doubles P=Q-P
\ Entry-
\   YX=block addr,C=1-borrow
\   block+0-3=P,+4-7=Q
\ Exit -
\   AXY undefined,CZN=as SBC,
\   block+0-3=Q-P,
\        +4-7 unchanged
\   Overwrites scratch.
STX scratch
STY scratch+1
LDY #4
.loop
LDA (scratch),Y \ get byte in Q
DEY \ move to same byte in P
DEY
DEY
DEY
SBC (scratch),Y
STA (scratch),Y
PHP \ flags for iter or return
CPY #3 \ finished
BEQ sbcdbldone
INY \ move to next byte in Q
INY
INY
INY
INY
PLP
JMP loop
.sbcdbldone
PLP
RTS
:
.cmpdbl
\ Compare 32-bit doubles Q-P
\ Entry-
\   YX=block addr,
\   block+0-3=P,+4-7=Q
\ Exit -
\   AXY undefined,CZN=as CMP
\   Overwrites scratch.
STX scratch
STY scratch+1
CLC
LDY #7
.loop
LDA (scratch),Y
DEY
DEY
DEY
DEY
BEQ cmpdbllast
CMP (scratch),Y
BNE cmpdbldone
INY
INY
INY
JMP loop
.cmpdbllast
CMP (scratch),Y
.cmpdbldone
RTS
:
.mindbl
\ Minimum of 32-bit doubles P,Q
\ Entry-
\   YX=block addr,
\   block+0-3=P,+4-7=Q
\ Exit -
\   AXY undefined,
\   block+0-3=min(P,Q)
\   Overwrites scratch.
JSR cmpdbl
BCS mindbldone
LDY #7
.loop
LDA (scratch),Y
DEY \ move to same byte in P
DEY
DEY
DEY
STA (scratch),Y
BEQ mindbldone
INY
INY
INY
BNE loop \ Z<>0 => BRA
.mindbldone
RTS
:
\ --- variable storage ---
:
.fhandle
EQUB 0
:
.errorcode
EQUB 0
:
.peer
EQUW 0 \ stn.net
:
.port
EQUB 0 \ client port
:
.fnameaddr
\ address of filename entered by
\ user
EQUW 0
:
.currpos
\ bytes transferred so far =>
\ offset of next byte
EQUD 0
:
.remain
\ remaining bytes to transfer
EQUD 0
:
.buffused
\ bytes of data in buffer
\ (typically starting at
\ buffer+13)
EQUW 0
:
.now
\ get_time fetches timer to here
EQUB 0
EQUB 0
EQUB 0
EQUB 0
EQUB 0
.timeout
\ expiry of timeout stored here
EQUB 0
EQUB 0
EQUB 0
EQUB 0
EQUB 0
:
\ DEBUG ROUTINES
:
.wrreg
PHA
LDA #ASC"("
JSR OSASCI
:
LDA #ASC"A"
JSR OSASCI
PLA
PHA
JSR wrbyte
:
LDA #ASC" "
JSR OSASCI
:
LDA #ASC"X"
JSR OSASCI
TXA
JSR wrbyte
:
LDA #ASC" "
JSR OSASCI
:
LDA #ASC"Y"
JSR OSASCI
TYA
JSR wrbyte
:
LDA #ASC")"
JSR OSASCI
PLA
RTS
]
:
REM this test is shakey if the
REM code block has overrun
REM following variables
IF P%-code%>codebuf% THEN PRINT "Code overran target buffer: ";P%-code%;">";codebuf%;" bytes":STOP
NEXT
PRINT "Code assembled at &";~code%;"+";~P%-code%
ENDPROC
:
DEFFNtx_mc(station%,port%,buffer,len%)
LOCAL X%,Y%
cblock?1=port%
cblock!2=station%
cblock!4=buffer
cblock!8=buffer+len%
X%=cblock
Y%=cblock DIV &100
=(USR(tx) AND &FF00) DIV &100
:
DEFFNrx_mc(station%,port%,buffer,maxlen%)
REM receive packet return #bytes
:
LOCAL X%,Y%,U%
cblock?2=port%
cblock!3=station%
cblock!5=buffer
cblock!9=buffer+maxlen%
X%=cblock
Y%=cblock DIV &100
IF (USR(rx) AND &8000)=0 THEN =-1
=cblock!9-cblock!5
:
DEFFNtx_bas(station%,port%,buffer,len%)
REM transmit packet
LOCAL A%,X%,Y%,delay%,result%,nonfatal%
:
timeout%=TIME+polltimeout%
REM loop until timeout or fatal
REPEAT
:
REM set up control block
cblock?1=port%
cblock!2=station%
cblock!4=buffer
cblock!8=buffer+len%
REM start transmission
A%=&10:REM transmit
X%=cblock
Y%=cblock DIV 256
REM loop until started
REPEAT
?cblock=&80
CALL OSWORD
UNTIL ?cblock<>0
:
REM poll for completion
REPEAT
A%=&32:REM poll transmit
result%=(USR(OSBYTE) AND &FF00) DIV &100
UNTIL (result% AND &80)=0
:
nonfatal%=(result%=&41 OR result%=&42)
UNTIL (NOT nonfatal%) OR TIME>=timeout%
=result%
:
DEFFNrx_bas(station%,port%,buffer,maxlen%)
REM receive packet return #bytes
:
LOCAL A%,X%,Y%
:
REM set up control block
?cblock=0:REM for cblock num
cblock?1=&7F
cblock?2=port%
cblock!3=station%
cblock!5=buffer
cblock!9=buffer+maxlen%
REM listen
A%=&11:REM receive
X%=cblock
Y%=cblock DIV 256
CALL OSWORD
:
REM poll for reception
A%=&33:REM poll receive
X%=?cblock:PRINT "P";~X%;
timeout%=TIME+polltimeout%
REPEAT
result%=(USR(OSBYTE) AND &8000)
UNTIL result%<>0 OR TIME>=timeout%
IF result%=0 THEN PRINT "Timed out waiting":A%=&34:X%=?cblock:CALL OSBYTE:=-1
:
A%=&11:REM receive
X%=cblock
Y%=cblock DIV 256
REM ?cblock populated above
CALL OSWORD
=cblock!9-cblock!5
:
DEFPROCdelay(n%)
REM delay n% cs
LOCAL limit%
limit%=TIME+n%
REPEAT UNTIL TIME>=limit%
ENDPROC
:
DEFFNmin(a,b)
IF a<=b THEN =a ELSE =b
:
DEFFNstation(station%)
LOCAL s$
s$=""
IF (station% DIV 256)<>0 THEN s$=STR$(station% DIV 256)+"."
=s$+STR$(station% MOD 256)
:
DEFFNneterror(err%)
IF err%=&40 THEN ="Line jammed"
IF err%=&41 THEN ="Net error"
IF err%=&42 THEN ="Not listening"
IF err%=&43 THEN ="No clock"
IF err%=&44 THEN ="Bad control block"
="ERR#"+STR$~err%
:
DEFPROCpkttest
LOCAL station%,key$
PRINT "PACKET TEST"
REPEAT
INPUT "Remote station? "station%
UNTIL station%>1 AND station%<255
:
REPEAT
PRINT "T(ransmit) or R(eceive): ";
REPEAT
key$=GET$
valid%=INSTR("TR",key$)<>0
IF NOT valid% THEN VDU 7
UNTIL valid%
PRINT key$
IF key$="T" THEN PROCtxtest(station%)
IF key$="R" THEN PROCrxtest(station%)
UNTIL FALSE
ENDPROC
:
DEFFNtx(station%,port%,buffer,len%)
REM PRINT "TX ";FNstation(station%);":";port%;" @ &";~buffer;"+";~len%
=FNtx_mc(station%,port%,buffer,len%)
:
DEFFNrx(station%,port%,buffer,maxlen%)
REM PRINT "RX ";FNstation(station%);":";port%;" @ &";~buffer;"+";~maxlen%
=FNrx_mc(station%,port%,buffer,maxlen%)
:
DEFPROCtxtest(station%)
LOCAL result%
$buffer="to:"+STR$(station%)
result%=FNtx(station%,port%+1,buffer,LEN($buffer)+1)
PRINT "Result=&";~result%
ENDPROC
:
DEFPROCrxtest(station%)
LOCAL bytes%
bytes%=FNrx(station%,port%+1,buffer,buflen)
PRINT "Bytes=";bytes%
IF bytes%<>-1 THEN PRINT "Received:<";$buffer;">"
ENDPROC
